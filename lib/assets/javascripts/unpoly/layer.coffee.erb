u = up.util
e = up.element

###**
Layers
======

TODO

@module up.layer
###
up.layer = do ->

  OVERLAY_CLASSES = [
    up.Layer.Modal
    up.Layer.Popup
    up.Layer.Drawer
    up.Layer.Cover
  ]
  OVERLAY_MODES = u.map(OVERLAY_CLASSES, 'mode')
  LAYER_CLASSES = [up.Layer.Root].concat(OVERLAY_CLASSES)

  # TODO: Document up.layer.config
  config = new up.Config ->
    newConfig =
      mode: 'modal'
      any:
        targets: [
          '[up-content=""]',
          # Define a default target that will close all overlays
          # and show an unexpected response in the <body>
          { layer: 'root', target: 'body', peel: true }
        ]
      root:
        targets: ['[up-content~=root]']
      overlay:
        targets: ['[up-content~=overlay]']
        history: true
        openAnimation: 'fade-in'
        closeAnimation: 'fade-out'
        dismissLabel: 'Ã—'
        dismissAriaLabel: 'Dismiss dialog'
        dismissable: true
      cover:
        targets: ['[up-content~=cover]']
      drawer:
        targets: ['[up-content~=drawer]']
        backdrop: true
        position: 'left'
        size: 'medium'
        openAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-from-left'
            when 'right' then 'move-from-right'
        closeAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-to-left'
            when 'right' then 'move-to-right'
      modal:
        targets: ['[up-content~=modal]']
        backdrop: true
        size: 'medium'
      popup:
        targets: ['[up-content~=popup]']
        position: 'bottom'
        size: 'medium'
        align: 'left'
        history: false

    for Class in LAYER_CLASSES
      newConfig[Class.mode].Class = Class

    return newConfig

  stack = null

  handlers = []

  isOverlayMode = (mode) ->
    return u.contains(OVERLAY_MODES, mode)

  defaultTargets = (mode) ->
    return u.flatMap(modeConfigs(mode), 'targets')

  ###**
  Returns an array of config objects that apply to the given mode name.

  The config objects are in descending order of specificity.
  ###
  modeConfigs = (mode) ->
    if mode == 'root'
      return [config.root, config.any]
    else
      return [config[mode], config.overlay, config.any]
      
  normalizeOptions = (options) ->
    up.legacy.fixKey(options, 'closable', 'dismissable')
    up.legacy.fixKey(options, 'flavor', 'mode')

    if u.isGiven(options.layer) # might be the number 0, which is falsey
      if options.layer == 'swap'
        if up.layer.isRoot()
          options.layer = 'root'
        else
          options.layer = 'new'
          options.currentLayer = 'parent'

      if options.layer == 'new'
        # If the user wants to open a new layer, but does not pass a { mode },
        # we assume the default mode from up.layer.config.mode.
        options.mode ||= config.mode
      else if isOverlayMode(options.layer)
        # We allow passing an overlay mode in { layer }, which will
        # open a new layer with that mode.
        options.mode = options.layer
        options.layer = 'new'
      else if options.layer == 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        options.layer = 'root'
    else
      # If no options.layer is given we still want to avoid updating "any" layer.
      # Other options might have a hint for a more appropriate layer.

      if options.mode
        # If user passes a { mode } option without a { layer } option
        # we assume they want to open a new layer.
        options.layer = 'new'
      else if u.isElementish(options.target)
        # If we are targeting an actual Element or jQuery collection (and not
        # a selector string) we operate in that element's layer.
        options.layer = stack.get(options.target, normalizeLayerOptions: false)
      else if options.origin
        # Links update their own layer by default.
        options.layer = 'origin'
      else
        # If nothing is given, we allow changes of any layer (preferring the current layer)
        options.layer = 'any'

    options.context ||= {}

    # Remember the layer that was current when the request was made,
    # so changes with `{ layer: 'new' }` will know what to stack on.
    # Note if options.currentLayer is given, up.layer.get('current', options) will
    # return the resolved version of that.
    # TODO: Test this
    options.currentLayer = stack.get('current', u.merge(options, normalizeLayerOptions: false))

  build = (options) ->
    mode = options.mode
    Class = config[mode].Class
    configs = u.reverse(modeConfigs(mode))
    options = u.mergeDefined(configs..., { mode, stack }, options)
    return new Class(options)

#  modeClass = (options = {}) ->
#    mode = options.mode ? config.mode
#    config[mode].Class or up.fail("Unknown layer mode: #{mode}")

  openCallbackAttr = (link, attr) ->
    return e.callbackAttr(link, attr, ['layer'])

  closeCallbackAttr = (link, attr) ->
    return e.callbackAttr(link, attr, ['layer', 'value'])

  reset = ->
    config.reset()
    stack.reset()
    handlers = u.filter(handlers, 'isDefault')

  open = (options) ->
    options = u.options(options, layer: 'new')

    # Even if we are given { content } we need to pipe this through up.change()
    # since a lot of options processing is happening there.
    return up.change(options)

  # TODO: Docs for up.layer.ask()
  ask = (options) ->
    return new Promise (resolve, reject) ->
      options = u.merge options,
        onAccepted: (event) -> resolve(event.value)
        onDismissed: (event) -> reject(event.value)
      open(options)

  anySelector = ->
    u.map(LAYER_CLASSES, (Class) -> Class.selector()).join(',')

  up.on 'up:fragment:destroyed', (event) ->
    for layer in stack.layers
      layer.repair()

  up.on 'up:framework:boot', ->
    stack = new up.LayerStack()

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  api = {
    config
    defaultTargets
    open
    build
    ask
    normalizeOptions
    openCallbackAttr
    closeCallbackAttr
    anySelector
  }

  u.delegate(api, [
    'get'
    'all'
    'push'
    'root'
    'overlays'
    'current'
    'front'
  ], -> stack)

  u.delegate(api, [
    'accept'
    'dismiss'
    'sync'
    'isRoot'
    'isOverlay'
    'on'
    'off'
    'emit'
    'parent'
    'child'
    'ancestor'
    'descendants'
    'history'
    'location'
    'title'
    'mode'
    'context'
    'element'
    'contains'
    'position'
    'align'
    'size'
    'origin'
  ], -> stack.current)

  return api

u.getter up, 'context', -> up.layer.context
