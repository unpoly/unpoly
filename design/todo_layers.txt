- consume-action
- Rails integration: test that up, up? etc. are available as helper methods
- Can we prevent the fragment from being updated when the update trigers a layer close? To prevent content flashing
- New attribute [up-emit]
  - For Unpoly links and forms this is another guardEvent (userGuardEvent)
  - For other elements this reacts on click
- Check new layer styles visually
  - Nested layers should have more padding
  - Cover should have no padding at all
  - Or maybe push background layers down and always keep the top modal at the same Y: https://atlaskit.atlassian.com/examples/core/modal-dialog/multiple
  - Modals should not have margin on small screens
- Check all occurences of up.emit and layer.emit:
  - Do they have a { log } option?
  - Do present tense events still have long-form event log messages with gerund?
- All calls of e.get(elementOrSelector) and e.first(elementOrSelector) might need to be changed to up.fragment.first(elementOrSelector) so they prefer the current layer
  - e. g. findValidateTarget
- Protocol options should not be configurable
  - Constants should just be props
  - Document headers in the main class docs
- Rename { base } back to { currentLayer }?
- Try changes in demo.unpoly.com
- What's our policy on acronym casing? We still have up.util.normalizeURL
- If we manipulate the { params } of a GET request in up:proxy:load, those params should be transferred to the URL, too (we need to re-normalize the request before we send it)
- Should up-modal-frame be up-modal-box?
- Hovering over a new [up-instant] link should abort all queued preload links
  - Preload links already in flight should not be canceled
  - Allow to disable this behavior for programmatic access, default could be { abort: { preload: true, queued: 'true' } }
  - For this we would need a state machine for requests:
    - 'initialized' ---> 'queued' --> 'loading' --> 'fatal' / 'ok' / 'error'
    -                       |              v
    -                       +--------> 'aborted'
    - 'initialized' ---> 'queued' --> 'loading' --> 'loaded' / 'fatal'
    -                       |              v
    -                       +--------> 'aborted'
    - Request#ok
    - Request#queued
    - Request#fatal
    - EVEN IF WE DONT DO THIS, it's not good to have isFatalError, but #aborted
- Move up:proxy:loaded and up:proxy:fatal to the Request that already emits up:proxy:aborted

There is also a typo in https://unpoly.com/tutorial that you might want to fix yourself (tutorial page does not seem to be part of the repo).

Have you noticed how noticed how pages fade in

- Tests
  - Test [up-content], [up-content=overlay]
  - test thtat up.reveal should only see obstructions on its laayer
  - test that up.reveal should peel by default
  - Test that fragment updates peel the targeted layer by default
  - Test that { peel: false } will not peel the targeted layer (especially now that up.viewport.scrollAfterInsertFragment/reveal also peels)
  - Test that up.viewport.closest() will match the closest OverlayWithViewport
  - Test that up.viewport.closest() will find a viewport in a parent layer if the element's layer is not an OverlayWithViewport
  - Test special overlay fallback:
    # Only for existing overlays we open will also attempt to place a new element as the
    # new first child of the layer's root element. This mirrors the behavior that we get when
    # opening a layer: The new element does not need to match anything in the current document.
  - Test: up:proxy:fatal is not emitted when a request was aborted
  - Test that up.reload takes { params } option: `up.reload('.author-select', { params: result.id }) } }``  - Test that event closers ({acceptEvent, dismissEvent}) can take both an array and a space-separated list of event types
  - Test: When a layer is accidentally removed from the DOM through a fragment update, it is either re-attached or dismissed (up.Layer#repair). In any case the stack is consistent after the update.
  - Test: History events are emitted on the history-enabled layer closest to the front
  - Test: Re-clicking the popup opener while the popup is open should close the popup instead of re-opening
  - Test that up:proxy:load has access to the { preload } attribute
  - Test that a modal opener with [up-instant] doesn't immediately close the new layer (because that closes on parent click)
  - Test that responses for a closed layer will not update anything
  - Test that up.validate will never update another layer, even if [up-layer] is set on the form and the server responds with 500
  - Test [up-accept-location="/foo/:user_id"]
  - TEst result = await up.layer.ask({ acceptLocation: "/users/:id"})
  - Test that the string callback to up-on-accepted can use the context { event, layer, value }
  - Test that the string callback to up-on-opening can use the context { event, layer }
  - Test that [up-params] will add additional query params to a followed links that already has query params
  - Test that [up-params] will add additional payload to a submited form that already has some fields
  - Test for up.element.isDetached()
  - Test that up-hungry will not activate in a background layer
  - Test that when a request was aborted, re-queuing the request will trigger a new network request (rather than returning the aborted version from cache)
  - Test layer focus behavior:
    - New layers should be focused
    - autofocus in new layers will be respected
    - when closing a layer, the element that originally opened the layer re-gains focus
  - Test that we can actually hit another layer if the initial plan failed
    - We had this for a while:
    - @successOptions.layer = successPreview.preflightLayer()
  - Test that all events during fragment change set up.layer.current
    - check if up:fragment:inserted sets up.layer.current
    - check if keep events sets up.layer.current
    - check if follow event sets up.layer.current
  - Test that validations keep focus
  - Test that layers without history updates still return their current #location
  - Change with { reveal: 'selector' } should not find elements in another layer
  - Test that this doesn't crash when we don't have parent
    - <form up-layer="parent" up-target=".list">
  - Test that accepting/dismissing the root layer will just follow the link
  - Test that proxy-events are emitted on their layer, not the document
  - Test that proxy-events are emitted a second time on the document if the layer has been detached
  - Test that proxy-events don't crash when a request has { layer: 'new' }
  - Test that proxy-events don't crash when a request has no { layer }
  - Test that updating <body> or <html> we keep layer.onEach handlers
  - Test that updating <body> will re-attach up-overlay elements
  - Test and document up.proxy.abort().
  - Test and document up.proxy.abort(request)
  - Test and document up.proxy.abort(conditionsObj)
  - Test that up.layer.get and up.layer.list take both a layer name like "root" or an options hash or an element or a jquery collection
  - Test layer { context } transmission
  - Test that all Change#execute() functions check if they're still applicable (or if the layer has been removed)
  - Test that back button closes all layers
  - Test that up.change() can be called with { target: Element }
  - Test that up.change() can be called with { target: Element } and will find in any layer
  - Test that up.change() without { layer } option will only find in current layer
  - Test that clicking on the layer backdrop will cause dismiss on iOS (https://code.makandra.de/makandra/studyflix/commit/cf7d016a1d00797519b709cfcb27423c6adea9d2)
  - Test that [up-dismiss][up-follow] inside a layer will dismiss, not follow
  - Test that [up-dismiss][up-follow] outside a layer will follow
  - Test that peeling is not preventable by preventing up:layer:dismiss
  - Test that opening/updating an layer can reset the world if selector is unavailable
  - Test against https://github.com/unpoly/unpoly/issues/79
    - Should be fixed by up.layer.onEach()
  - Test defaults inheritance in layer hierarchy (all => overlay => mode)
  - Test that a layer cannot have history: true if its parent has history: false
  - Test that making a layer change in an { onAccepted } callback will not deadlock the acceptance change
  - Test that layers are assigned .up-destroyed class while closing
  - Test that default targets are selectable per layer-type
  - Test that default targets are also fallbacks per layer-type
  - Test non-standard failOptions:
    - failOptions: mirror
    - failOptions: inherit
  - Test that that all layer methods manipulate the stack in sync (peel, push, remove)
    - E.g. opening the layer twice in a row fails currently: up.layer.open({ content: '<div class="content">foo xxx xxx</div>', target: '.content' }); up.layer.open({ content: '<div class="content">xxx</div>', target: '.content' })
    - It's OK for animations to run async after that
  - Test that ResetWorld is actually happening
  - Test that up.change({ content: 'foo' }) works when 'foo' is just text, without a wrapping tag
  - Test that we can submit a form into a new layer (success / fail)
  - Test up.proxy.abort()
  - Test that opening a new layer cancels requests that also open a new layer
  - Test { abort: 'conflict' }
  - Test that closing a layer cancels all requests for that layer
  - Test that up.change(html: Element) works
  - Test that forms can submit as arbitrary layer changes (success and failure)
  - Test that [up-on-accepted] and [up-on-dismissed] get the link's layer as up.layer.current
  - Check that up.layer forwards getters for all layer properties to stack.current
  - Test that compilers always see their up.layer.current, even if it is a background update and there is another layer above it
  - A11Y: current layer should get [role=dialog] and [aria-modal=true], all parent layers should get [inert] and [aria-hidden: true]. Since the root layer has no containers, we should apply this to direct children
  - A11Y: opening a layer should focus the layer, optionally to [autofocus]
  - A11Y: closing a layer should focus the element that opened the layer, or if the opener is unknown, the parent layer
  - Test Rails integration
  - UpdateLayer should re-create default targets
    - E.g. I have up.layer.config.modal.targets = ['.content', '.menu']
    - Now that layer was opened with .menu
    - The next request only has .content
    - => We should clear out the modal and build a new .content, since that is also what we would do on "new"!
    - => In case that the current modal DOES have .content we should update this instead of re-rooting
  - Tests for up.modal and up.popup should do nothing but test the legacy fallbacks
  - up.Params#has

- Docs
  - Document request queue changes
    - Preload limits
    - New options
    - It's LIFO now
  - up:fragment:loaded
  - [up-content], [up-content=overlay], ...
  - Update better_errors card
    - should use up:fragment:loaded
    - should use request.loadPage() instead of request.navigate()
  - Don't document each option a second time as failVariant. Instead explain in the method doc and { failOptions } what to do here.
  - [up-follow] vs. [up-target] vs. [up-layer] vs. [up-modal] etc.
    - Move all fragment update docs to a[up-follow] and form[up-follow]
    - There are separate doc entries for a[up-target] and form[up-target]
    - There are separate doc entries for a[up-layer] and form[up-layer]
      - These have all the layer-specific options
  - We now have unpoly-bootstrap3 and unpoly-bootstrap4
  - Fix unpoly-guide; The fullscreen-mode should just be up-mode="cover"
  - All layer-related options should be moved to a[up-layer] or form[up-layer] or both
  - Document changes in options { history } (now boolean) and { location } (now a string) changes
  - Document new emit options { layer, base }
  - up.preload() can now fail if preloading is disabled
  - Docs: up:form:submit event now has { options } to manipulate
  - Docs: up:link:follow event now has { options } to manipulate
  - Expose up.fragment.all() as experimental API
  - Update Card and Slide for Testing config (maxRequests => concurrency, preloadConcurrency, disable preloading entirely)
  - { navigate }
  - Document that up.on selector can be a function
  - I think the slow/recover events changed
  - New gerund-events (up:layer:opening)
  - { failOptions }
  - up.link.config
  - New up.Request properties (at least { origin }, { layer })
  - Publish up.Request#loadPage()
  - Document that { target } can be an array
  - Document up.proxy.abort().
  - Document up.proxy.abort(request)
  - Document up.proxy.abort(conditionsObj)
  - Document [up-dismiss-on="click .button"]
  - Document up:proxy:aborted
  - Document new Rails integration
    - Document up.redirect_to
  - Document Protocol changes for other integrators
  - More Documentation from Diff
  - CHANGELOG from diff



Finishing up
------------

- Remove unused files after we copied all documentation
  - popup
  - modal
- Grep for TODO
- Test in all browsers
- Migrate cards
- Migrate a Webpacker app
- Fix up-guide
  - Simplify content-link, modal-link, drawer-link
    - This should just be layer-link
  - up_modal.sass
- E-Mail maintainers of rack-unpoly und unpoly_ex


Accessibility
--------------

- A11Y: check if [inert] etc. are enough to have the browser rotate focus within the layer
-

Later?
------

- up.validate() is strange to preview a form change
  - maybe offer up.form.preview() and up-preview=".selector"
  - would be useful to preview another field without triggering validations? would this even work in rails, where a lot of logic hangs on validation hook?
  - then in the inspector:
    - def up.preview?; validate? or request['X-Up-Preview']; end
- Instead of normalizing URL strings and carefully making sure to never double-normalize the same string (for performance reasons), have an exposed up.Location object that toString() to its origin URL. Normalizing can happen when comparing.
- Make the { request } available to up:fragment:inserted, so we can have a variant of https://makandracards.com/makandra/79164 that does not react to { preload } events
- When xhr.responseURL is not the requested URL, assume that there was a redirect and the response method is now GET
- Rename request-related events
  - up:request:load
    up:request:loaded
    up:request:fatal
    up:request:aborted
    up:network:slow
    up:network:recover
  - Possibly rename up.proxy to up.request?
    - What about the up.request method?
      - up.request.fetch()?
- Allow shortcuts like up-any-target that set both success and fail options (if up-fail-options is not sufficient)
- Allow placement of body in overlays with <up-body>
  - Then <body> can really be a default target for all fragments
  - Is this really a good idea? It would break for all pages that use fixed elements in their layout
- Allow per-Layer fragment access like
  - layer.fragment.first()
  - layer.fragment.all()
  - layer.fragment.destroy()
  - layer.fragment.reload()
- Should we track/stop animations and scrolling per layer instead of globally?
- Get rid of up:framework:booted event
- Rename up:proxy:load etc. to up:request:load
- Events like up:layer:child:open
- Does up.remove() clean up jQuery data?
- { peel } option for up.destroy
- Do we want an ExtractPlan.BackButton? Turbolinks keep [up-keep] for back.
- Support [up-target][up-class] and [up-target][up-fail-class] to set a class on the new fragment
  - But think how that would go together with [up-layer="new"][up-class="warning"]
- Support :destroy pseudo-class up up.change() target
- Do we need an API to change context from JS? from server via header?
- Should up.reload / up.change etc. resolve to the updated elements?
- There should be a preload() function in up.proxy, but that should also take a request
  - For this we also need to decide whether up.proxy.preload() would reject unsafe requests
- form[up-target] without a target now looks funny
  - I now have form[up-follow] as a workaround
- When up:proxy:load is prevented, the request should be resolved with an AbortError
- Replace up.Response.isSuccess() with up.Response#ok
- Replace up.Response.isFatal() with !up.Response#body
- Emit up:proxy:fatal when responses are aborted due to user or timeout
- up:fragment:inserted should receive the entire document from which the fragment was extracted
- Support named layers
- Better cache hits (uhm really?)
  - When accessing up.target etc. the server should track this and respond with
        X-Up-Tailored: ["target", "mode"]
  - We can then use this information to resolve other requests in the queue
  - => But this would only help for requests already in the queue, yes? Because new requests would need to wait what the server responds.
- If all layers have their own implementation anyway, should we re-visit zones?
  - <a href="/foo" up-target=".bar" up-mode="zone" up-anchor=".slot"> (oder up-orgin? naa...)
  - -<div class="slot">
        <up-zone>
          <up-zone-content></up-zone-content>
        </up-zone>
     </div>
  - Should the term "layer" be renamed with "zone" everywhere?
  - This might be more useful if we had multiple children per layer
- Habe ich / will ich up-accept für forms? E. hätte das nicht gebracht, da er erst nach abspeichern
  - up-dismiss-now
  - up-dismiss-after
  - up-dismiss-with-result
    - aber was ist dann das ergebnis? ich könnte hier nur ein leeres ergebnis geben


Decisions
---------

- Entscheiden ob ich die [up-modal], [up-drawer], etc. Shortcuts behalten möchte
  - Für Docs?
  - Verwirrend dass es mehrere Möglichkeiten gibt, das gleiche zu machen?
  - up-layer="new"
  => Ja, behalten
- The up.layer package object should be a looked up to "current", since TK naturally expected this to be the current layer
  => Das bringt nichts, dann kann man ja eben nicht sich was wergmerken
- Is { navigate } is really the best name for the option? Maybe { solo } or similar?
  - Keeping { navigate } means we could also use it for A11Y things
  => Gibt keine bessere Idee
- { flavor } umbenennen in { mode }, { scheme } oder { interface }
  - mode: Evtl. habe ich später mal nicht-modale Layer?
  - mode: 'modal' ist doof
  => Es ist nichts wirklich besser
- Should [up-href] be [up-url] to match { url }?
  - No, it matches HTML5 or XHTML2
- Params
  - Separate { query } and [up-query] options
  - NEVER move URL query to payload params
  - GET submissions: Form values should override, not append (set, not add) values from query
- Do I really want up.Change.ResetWorld instead of <body> as root's default target?
  - Yes, if we cannot match an overlay target we want to reset the world
  - One could argue that we only need ResetWorld when we're creating a layer or updating an overlay
- Should up.emit without an element emit on the document or on the current layer? => Keep it on document, as it is now!
- Should we keep up.history.popTargets?
  - up.config.root.targets might not be appropriate
  - but the layer targets will always be options after .popTargets, so we can keep popTargets as empty
- up.fragment.config.fallbackTransition wieder rein?
  => Nein, man kann ja das fallback als { objekt } machen
- It's stupid to have both { layer } and { mode } when one can set both
  => No, we don't want up.layer.open({ layer: 'modal' })
- Should it be up.accept(), up.dismiss(), X-Up-Accept, X-Up-Dismiss? => No
- Should the default layer be current again?
  => Not now, maybe change that leter
- Decide whether to do up.layer.accept({ value: { flight_id: 5 }}) or up.layer.accept({ flight_id: 5 })
  => We keep the value as first argument for the symmetry to resolve / reject
- Decide whether to still up <up-xxx-frame> to more easily position the dismiss icon
  => No, in popups the <up-popup> is the frame. we can position a dismiss icon in that.
