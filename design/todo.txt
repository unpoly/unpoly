TODOs for next release
======================

Concurrency
-----------

- Keep config.validateOptions, but [up-validate] should also use [up-observe-event] & friends
  - So fewer attributes
  - config.validateOptions inherits from config.observeOptions, overriding { delay: 0 }
- Allow { keep: 'selector' } to define additional elements to keep
  - Document this lets us validate-on-input:
    - <input up-validate up-event="input" up-keep="&">
- Now that we're verifying cache, increase the cache default time from 5 minutes to 20 minutes
- Test that the default validateOptions.event for an input[type=date] is "blur", not "change"
- Parse and use { disable } while an [up-observe] callback is running
  - We should disable fields without help by the user
  - Strip { disable } from field options passed to observe callback, since we already processed it
  - No up.render() here!
- Support more than one [disable] option
  - [disable=form] (gleich wie true, kann auch selektor sein)
  - [disable=form-group]
  - [disable=submit-button]
  - [disable=selector]
  - [disable=false]
  - Evaluate in up.Change.FromURL
    - Keep logic reusable for disabling during async up.observe() callbacks
- Move mimicLocalRequest() into useCachedRequest()
- Serialize *all* actions in a form
  - We keep the "schedule next" logic from up.FieldObserver, but we simply render with { sequence: 'form' }
  - The new default form submit/observe/validate is { sequence: 'form' }
  - Can be overriden bei individual inputs with [up-observe/autosubmit/validate]
  - The sequence is not handled by up.form or up.FieldObserver
    - Instead it is a property of up.Request().
    - up.Request() resolves { sequence } to an element, using up.fragment.get(this.sequence, { layer: this.layer, origin: this.origin })
  - The up.Request#sequence property is handled by up.Request.Queue.
    - When up.Request.Queue picks the next request to load, it skips over requests if there is a currently loading request for the same { sequence }
      - Two sequences collide if their sequence elements are in the same dynasty, e.g. a.contains(b) or b.contains(a)
    - This has the benefit that requests in a sequence can be *aborted* while they wait for their turn
    - To make { sequence } work for cached content we also queue cached responses
      - Cached responses must *not* resolve immediately, but only when the queue calls #load()
        - Move up.Request#followState() to up.Request#load()
      - Don't emit up:request:load or up:request:loaded for cached responses
- { sequence } should be an option that is overridable per-field in FieldObserver, config.validateOptions, etc.
- When iterating over all fields for individual observe()s, we really need to go over all groups with the same [name]


Various changes
---------------

- Rendering: allow { scrollBehavior: 'smooth' } when we're not morphing
  - Could we even allow this *when* morphing?


Docs
----

- Document [up-verify-cache], render({verifyCache}) and up.fragment.config.autoVerifyCache
  - This may be a new caching page
- New observe() and validate() options
  - { feedback, disable, delay, event }
- [up-observe-feedback], [up-observe-disable],  [up-observe-delay],  [up-observe-event]
  - [up-autosubmit] needs options params that attributes for [up-observe] may be used
- [up-validate-feedback], [up-validate-disable],  [up-validate-delay],  [up-validate-event]
- up.form.config.submitOptions
- up.form.config.observeOptions
- up.form.config.validateOptions
- Consider consolidating docs for
  - input[up-observe]/form[up-observe] as well as
  - input[up-validate]/form[up-validate]
  - input[up-autosubmit]/form[up-autosubmit]
  - ... so it's only "within the container"
- Missing docs for render options
  - { revealTop }
  - { revealMax }
  - { revealPadding }
  - { revealSnap }
  - { scrollBehavior }
    - if we stop auto-set it to auto, otherwise stop parsing this

Maybe
-----

- Consider renaming "*observe*" to "*watch*"
  - Maybe take this opportunity to change the attribute?
    - <form up-watch up-watch-event="change" up-on-changed="...">
    - up.watch(field, 'change', function() { ... })
    - Keep the callback signature like it is
- Allow to prevent Unpoly's state restoration handling with a preventable up:history:restore
  - We're currently forwarding an event up:history:restore to up:location:changed, but that was never public API
- Replace up.hello() and up.syntax.clean() to MutationObserver()
- Do we want to serialize all actions in a form?
  - up-sequence="form"
  - This would need to abortable on submit => Would be handled by existing { solo: 'subtree' } IF there is a request
  - This would need to abortable on form destroy => Would be handled by existing { solo: 'subtree' } IF there is a request
  - => This would need to be handled by up.Queue, or else there would be nothing to abort
  - => It is not sufficient to have up.form.sequence(..., callback)
  - => We would need to do something like { sequence: ElementOfSubtree }
  - => Before picking a new request, make sure no existing request exists
  - What about our old idea: { order: 'abort target', order: 'abort form', order: 'after form', order: 'after selector' }
      => How to say "after ElementObject" ?
  - Who would fetch the element that is 'form' or 'selector'?
      => up.Change.UpdateLayer#preflightProps(), which already loads targetElements()
  - What would we do if both was given, e.g. { solo: true, sequence: 'form' }
    - Do we forbid the combination?
    - Do we first abort, then do a squence?
    - Do we first wait, then abort? => I think this, but this also means our { solo } handling is in the wrong place. It must move to the queue.
  - Does { sequence: 'form' } also queue local content, like { solo } ?
   - We could do something like up.LocalRequest, but then local updates would no longer be sync!
   - We could not support { sequence } for local updates => YES
  - What about cached content with { sequence }?
    - We could do queue.asapLocal() which immediately executes unless there is { sequence }
  - How does queue resolve a sequence?
    - Before dispatching a request with { sequence }
    - Check if we have *current* requests with { sequence }
    - If any of the other requests's sequence contains our *or* if any other sequence is contained by ours, don't dispatch
- Guard Events for Rendering could have a Promise for "done"
  - Is this better than setting event.renderOptions.onFinished()?
    - Yes, because onFinished may not fire for fatals or prevented up:fragment:loaded
  - How would this work together with future up.RenderRequest?
  - How would this work together with "local changes are sync"?


Long term solution
------------------

- Consolidate [up-validate], [up-switch] and [up-observe] into a tree of form dependencies
- This way we can selectively disable parts of the form


Backlog
=======

- Improve `{ focus: 'keep' }` so it focuses the former form group if we lose focus
  - This may be easier said than done
    - we would need to remember the original form group before the swap in the FocusCapsule
    - re-discover the form group in the new HTML
    - check that the form group is a closer match than target-if-lost
    - come up for a better name for the option (target-if-lost)
- New event up:request:solo ?
- Consider delaying appending of new layer elements until we have constructed all children https://github.com/unpoly/unpoly/discussions/314
- CheapEnergy hatte bedarf auf "[up-validate] on input"
- CheapEnergy hatte bedarf auf "[up-validate] mit delay"
- Publish { onQueued }
  - More canonic would be if up.render() returned a up.RenderRequest, which has abort().
- Wir aborten bereits laufende [up-validate] wenn das Formular submitted, wird, aber laufende Observer-Delays warten können danach noch Dinge tun
  - Wie wäre "submit stoppt das delay"?
  Evtl. Warnung ausbauen: "Will not observe fields without [name]"
- [up-emit] auf Buttons erlauben
- Beim Schließen des Modals prevented jemand up:layer:dismiss, und dann steht "Abort Error: Close event was prevented" in der Konsole.
  - Wollen wir das schlucken?
  - Zumindest bei ui-elementen wie [up-dismiss] ?
- DestructorPass sammelt zwar Exceptions, aber wirft am Ende. Wer fängt das dann? Der Wunsch wäre, dass das drumrumliegende up.destroy() noch zu Ende läuft, dann aber up.CompilerError wirft.
- ConstructorPass sammelt zwar Exceptions, aber wirft am Ende. Wer fängt das dann? Der Wunsch wäre, dass das drumrumliegende up.render() oder up.hello() noch zu Ende läuft, dann aber mit up.CompilerError rejected.
- Update "Long Story" Slides with new API
- Doc page about "Fragments from local HTML"
  - link from [up-document], [up-fragment], [up-content], { document, fragment, content }.
- Warn when registering compiler in [up-] namespace
- Do we need window.history.scrollRestoration = 'manual' ?
  - Is this setting per-state?
