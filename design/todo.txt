TODOs after V3
==============

- Extend [up-switch] with [up-disable-for="..."] [up-enable-for="..."]
  - Or should we have an [up-switch-for] and [up-switch-effect]?
- up:feedback:start / up:feedback:stop
  - On the layer, not an individual element
  - Needs to have reference to origin and targetElements
- Consider parsing scroll-margin-top, scroll-margin-bottom for revealing
- Allow [up-emit] for buttons
- Honor `Vary` for cache keys (hard!)
- Do we want a preventable up:fragment:hungry event?
- Do we want a preventable up:request:reuse event?
  - Maybe even :reused since there is no :loaded for cached requests
- Experiment with property mangling vs. public API
- Issue with splitting Immediate-Child-Selectors: https://makandra.slack.com/archives/C02KGPZDE/p1659097196752189
- This always passes: expect(window).not.toHaveUnhandledRejections()
  - All rejections seem to be delayed until the test ends
  - Maybe a Jasmine issue?
- Can we get rid of the afterMeasure() callback?
- Support { scroll: 'keep' }
  - Similiar to { focus: 'keep' }
  - Store scrollTops around a viewport in UpdateLayer
  - Possibly refactor tops to up.ScrollTopsCapsule
- Check that the target (and all non-successful target attempts) are visible in the log
  - Possibly highlight
- Do we want to support ` or ` in targets?
  - Is there any case other than [up-target], where we already have [up-fallback] ?


TODOs for V3
============


State transfer
--------------

- Test if we can preserve element.upPolling in data



Various changes
---------------

- Test with other browsers
  - Firefox
  - Edge
  - Safari



Docs
----

### New/reworked pages overview

/caching
/disconnects
/target-derivation
/disable-option
/watch-tuning ?
/defaults or /options
/render-lifecycle (maybe)


### Render rework

- Possibly new page for lifecycle chart
  - This could explain when a promise settles vs. when everything is finished
- Document up.render().finished
- Document all lifecycle callbacks for up.render() (JS) and a[up-follow] (HTML)
  - onOffline is not parsed or documented anywhere
    - a[up-follow][up-on-offline]
    - parse in up.link.followOptions
    - up.render({ onOffline })
  - onRendered is not parsed or documented anywhere
    - up.render({ onRendered })
    - parse in up.link.followOptions
    - a[up-follow][up-on-rendered]
    - explain that it may be called twice with revalidation
    - explain that it's not called when no content is rendered
  - onError is not parsed or documented anywhere
    - up.render({ onError })
    - parse in up.link.followOptions
    - a[up-follow][up-on-error]


### New cache / revalidation

- New doc page explaining caching
  - On by default
  - Cache revalidation
  - expire vs. evict
  - Migrate existing text in up.network (h2 "Caching")
  - Migrate existing text in up.request (there are links to up.request#caching)
- up.render({ cache })
- up.render({ cache: 'auto' })
- up.request({ cache })
- up.request({ cache: 'auto' })
- a[up-follow][up-cache="auto"]
- Point existing links to new /caching page
- Protocol headers
  - ETag / If-None-Match
  - Last-Modified / If-Modified-Since
  - Link from places where we talk about `304 Not Modified` or `204 No Content`


### Watch/validate rework

- Document { disable } and [up-disable] option for up.submit(), form[up-submit]
  - The /disable-option page is there, but still empty
  - Maybe even for up.render()
  - Maybe even for a[up-follow]
- Consider consolidating docs that are currently documented separately for input/form, so it's only "within the container"
  - input[up-watch]/form[up-watch] as well as
  - input[up-validate]/form[up-validate]
    - Explain [up-validate] usage for radio buttons
  - input[up-autosubmit]/form[up-autosubmit]
  - Fix Links
  - Update .htaccess
- Rework [up-validate] so it talks more generically about dynamic forms rendered on the server
- New watch options [up-watch-feedback], [up-watch-disable],  [up-watch-delay],  [up-watch-event]
  - Document at [up-watch]
  - [up-watch-delay] attribute should always be optional; Explain how it often defaults to up.form.config.watchInputDelay
  - [up-autosubmit] needs a params note saying that that attributes for [up-watch] may be used
  - [up-validate] needs a params note saying that that attributes for [up-watch] may be used
  - Explain that they can be set either on the form or on an input
- Docs for up.validate()
  - Document the many ways to target an element (see up.form.parseValidateArgs)
  - { feedback, disable, delay, event }
- New watch() and validate() options
  - { feedback, disable, delay, event }
  - Explain that you can use it both on containers and individual fields
- Document all the ways we prevent concurrency
  - In up.watch()
  - In up.validate()
  - Document that multiple [up-validate] requests are merged into a single request
- Test and Document that we can use live validation like this:
  <input up-keep up-validate up-watch-event="input">
- X-Up-Validate header
  - Document that X-Up-Validate may contain multiple names
  - Document that X-Up-Validate may contain :unknown


### Offline

- New topic page for "offline"
- a[up-follow][up-on-offline]
- up.render({ onOffline })
- up.request({ onOffline })

- up:fragment:offline
  - experimental
  - event.retry(options)
    - Is there a test for that?
- Explain how Unpoly reacts when accessing an offline resource
  - Stale content is updated, but not revalidated
  - Content frame is kept
- Document how to build an "you're offline. retry?" toast:
  - <a up-follow up-offline="if (confirm('Offline, retry?') event.retry()">
- Explain that the initial request requires a service worker like the one from UpUp (no relation)



### Target derivation

- Possibly own page
  - Document which features require targetable elements
    - up.render(Element)
    - up.reload(Element)
    - [up-poll]
    - [up-hungry]
    - up.radio.config.hungrySelectors
      - Note that the configured selector will be re-derived
    - [up-viewport]
    - On the doc pages for these elements
      - Link to derivation
  - Redirect links to up.fragment.toTarget


### Other docs

- Replace ASCII art with picture for aborting-requests.md#aborting-conflicting-requests
- Fragment Placement
  - alternatives with ` or `
  - where else is ` or ` supported?
- onError
  - consider a full try / catch example in /failed-respoinses
  - /failed-responses should also explain onError
- config.pollIntervalScale
- Config props should be child nodes in unpoly-site's browser
- Consider replacing type|undefined with type? in all type comments
  - Test that a `?` may be part of a type in the parser
- Go through TODO
- Go through visibilities
- Consider a new page for defaults
  - I know no better @parent than up.util :/
  - Explain that most opts are opt-in
  - Explain navigation defaults
  - Explain config objects
  - Explain auto-Configs
  - Explain that you can often override renderOptions in event handlers
- Targeting content
  - Überall wo [up-target] oder { target } dokumentiert ist nach https://unpoly.com/targeting-fragments verlinken
  - Include or link to /target-derivation
- Document django-forms-dynamic for [up-validate]
  - https://twitter.com/j4mie/status/1471610935924215815?t=KtCISFJXz3kEMoc6C3y4UQ&s=09
  - https://github.com/dabapps/django-forms-dynamic
- up.form.config.inputEvents
- up.form.config.changeEvents
- up.form.config.inputDelay
- Missing docs for render options
  - { revealTop }
  - { revealMax }
  - { revealPadding }
  - { revealSnap }
  - { scrollBehavior }
    - Explain that this is currently only supported for prepending and appending
  - Also attributes for a[up-follow]



V3 Launch
---------

- Track CHANGELOG with changes done since the V3 presentation
- We don't need anything from Ops
  - We already have v2.unpoly.com, it just redirects to unpoly.com (via .htaccess in Git) while the current version is v2
- Make an 2.x-stable branch for unpoly-site
- Make an 2.x-stable branch for unpoly
- We need a separate Algolia index for v2
  - v3 would stay on "latest"
  - use that index in unpoly-site/2.x-stable
- Update the version switcher to include 3.x on v2.unpoly.com and the new unpoly.com
- Add a "You're viewing docs for an old version of Unpoly" banner to v2.unpoly.com
- *Maybe* have a pre.unpoly.com
- The README says "Unpoly 2"
  - Needs to say Unpoly 3
  - Needs to link to 2.x-stable branch
- Submit to to https://github.com/github/release-radar/
- Open heads-up issues for server integration maintainers
- Update Glitch template: https://glitch.com/edit/#!/empty-unpoly-project



Icebox
======

- Allow late registrations of compilers and macros without priority
  => OK for compilers, but what about macros? They have an intrinsic priority (before all compilers)
- Consider whether up.validate() promises should wait until no more solutions are pending
  => We would need to merge RenderResult#target in some meaningful way
- Rename "finished" to "concluded"
- Should up:click set up.layer.current ?
  - It would be more convenient, but it's only relevant for popups or backdrop-less modals. This is rare.
- New onTransitioned() callback to take some load off from onFinished()
- Move scroll positions into state
  - This gets rid of the other up.Cache usage
  - This may mean we need to lose up.viewport.restoreScroll() and { scroll: 'restore' } and { saveScroll: true }
    - Losing { scroll: 'restore' } is super sad :(
  => Maybe revisit when the Navigation API is supported
- Improve polling in the background
  - It would be great to *not* have a timeout running while we're in the background or offline
  - It would be great to not wait up to 10 seconds when we're re-focused or regain connectivity
- Elemente mit [up-hungry][up-layer=any] müssten wir *eigentlich* auch austauschen, wenn wir einen neuen Layer öffnen
  - OpenLayer kann aber gar nicht mit mehreren Steps umgehen
- can badResponseTime be a function that takes a request?
  => Yes, but not trivially
- Consider using `Cache-Control: stale-while-revalidate=<seconds>` to indicate how long we can use a response
  - But it could be paired like this: Cache-Control: max-age=1, stale-while-revalidate=59
  - But then again we ignore Cache-Control for all other purposes
    - E.g. Cache-Control: no-store
    - E.g. Cache-Control: max-age
    - How would Cache-Control: no-cache (equivalent of max-age=0 must-revalidate) work in connection with up.fragment.config.autoRevalidate ?
  - Maybe do a bigger workover of Cache-Control?
- Do follow links with [target=_self]
- up:click forking could print a warning when an a[href] is instant, but not followable
- Is it weird that up.layer.affix appends to the first swappable element instead of the contentElement?
  - It's actually more like "appendableElement"
  - Maybe offer up.Layer#append
- Consider exposing up.layer.contentElement
- Do we want a shortcut macro for this:
      <input up-validate up-keep up-watch-event="input">
  - <input up-live-validate>
  - It's weird for users who don't target the input. They may expect to just override the event.
- We could support this with more pseudo-class selectors like :form-group and :submit-button
  - :submit-button is hard to build origin-aware => It could just be a substitution with :is() / :-moz-any() & :-webkit-any()
  - :form-group is also supper hard to support in a selector like ".foo, :form-group, :bar" due to the way we hacked :has()
    - :has() is still behind a flag in Chrome and no Firefox support
- Introduce boundaries or "softly isolated zones"
  - The idea started with: Should fragment lookups with an { origin } within a form prefer to look within the form?
    - Also related to https://github.com/unpoly/unpoly/issues/197 , which would no longer work
      now that a form submission's orgin is the submit button instead of the form element
  - E.g. <div up-boundary>
    - Lookups within prefer to match within the boundary
    - It's a new fallback target
      - Also for errors
    - up.fragment.config.boundaryTargets = ['[up-boundary]', 'form', ':main']
    - Is this also controlled by { fallback }?
    - Maybe identification using [up-boundary=123]
      - But don't enforce this, it's not a great auto-target
    - Should this rather be [up-zone]?
      - If we ever make fully isolated containers we would call them frames
        - https://github.com/unpoly/unpoly/discussions/350
    - We could also offer :zone as a selector
    - Would we still offer { target: '.container .child' }?
      - Would we offer { target: ':zone .foo' }, since it's really the same as { target: '.foo' } ?
    - Is this a repetition of "fragment needs to know whether it is used as component or main target"?
      - We would need to fix infinite looping in expandTargets()
      - It would be nice to disable history in a zone
        - but then it's not usable as a main target
        - Disable history in a container?
          - It's weird to nest multiple containerish elements
        - => This is really already solved through { history: 'auto' }, which only updates history if updating :main
- Rendering: allow { scrollBehavior: 'smooth' } when we're not morphing
  - Could we even allow this *when* morphing?
- What is the purpose of up.error.emitGlobal?
  - Don't we throw a compound error that would be tracked?
    - We do
    - But the error does not bubble up
    - What do we want here?
- New up.render() options to clone from a template
  - { documentTemplate }, { fragmentTemplate }, { contentTemplate }
  - Separate doc page "Rendering from local content"
  - Fail when template cannot be found
  - But what if I really need to re-use an existing element that is then placed back into the body, like in WB?
- Consider implementing an abortable up:navigate event
  - This would be the first feature that goes beyond "navigation is just a preset"
  - People might expect history changes to trigger this
  - Maybe think about this more
- Allow to prevent Unpoly's state restoration handling with a preventable up:history:restore
  - We're currently forwarding an event up:history:restore to up:location:changed, but that was never public API
- Replace up.hello() and up.syntax.clean() to MutationObserver()
- Do we want to serialize all actions in a form?
  - up-sequence="form"
  - This would need to abortable on submit => Would be handled by existing { solo: 'target' } IF there is a request
  - This would need to abortable on form destroy => Would be handled by existing { solo: 'target' } IF there is a request
  - => This would need to be handled by up.Queue, or else there would be nothing to abort
  - => It is not sufficient to have up.form.sequence(..., callback)
  - => We would need to do something like { sequence: ElementOfSubtree }
  - => Before picking a new request, make sure no existing request exists
  - What about our old idea: { order: 'abort target', order: 'abort form', order: 'after form', order: 'after selector' }
      => How to say "after ElementObject" ?
  - Who would fetch the element that is 'form' or 'selector'?
      => up.Change.UpdateLayer#getPreflightProps(), which already loads targetElements()
  - What would we do if both was given, e.g. { solo: true, sequence: 'form' }
    - Do we forbid the combination?
    - Do we first abort, then do a squence?
    - Do we first wait, then abort? => I think this, but this also means our { solo } handling is in the wrong place. It must move to the queue.
  - Does { sequence: 'form' } also queue local content, like { solo } ?
   - We could do something like up.LocalRequest, but then local updates would no longer be sync!
   - We could not support { sequence } for local updates => YES
  - What about cached content with { sequence }?
    - We could do queue.asapLocal() which immediately executes unless there is { sequence }
  - How does queue resolve a sequence?
    - Before dispatching a request with { sequence }
    - Check if we have *current* requests with { sequence }
    - If any of the other requests's sequence contains our *or* if any other sequence is contained by ours, don't dispatch
- Guard Events for Rendering could have a Promise for "done"
  - Is this better than setting event.renderOptions.onFinished()?
    - Yes, because onFinished may not fire for fatals or prevented up:fragment:loaded
  - How would this work together with future up.RenderRequest?
  - How would this work together with "local changes are sync"?
- Consolidate [up-validate], [up-switch] and [up-watch] into a tree of form dependencies
  - This way we can selectively disable parts of the form
- Functionality that checks for isDetached() should probably also check for .up-destroying
- Improve `{ focus: 'keep' }` so it focuses the former form group if we lose focus
  - This may be easier said than done
    - we would need to remember the original form group before the swap in the FocusCapsule
    - re-discover the form group in the new HTML
    - check that the form group is a closer match than target-if-lost
    - come up for a better name for the option (target-if-lost)
- New event up:request:solo ?
- Consider delaying appending of new layer elements until we have constructed all children https://github.com/unpoly/unpoly/discussions/314
- Publish { onQueued }
  - More canonic would be if up.render() returned a up.RenderRequest, which has abort().
- Wir aborten bereits laufende [up-validate] wenn das Formular submitted, wird, aber laufende Watcher-Delays warten können danach noch Dinge tun
  - Wie wäre "submit stoppt das delay"?
  Evtl. Warnung ausbauen: "Will not watch fields without [name]"
- [up-emit] auf Buttons erlauben
- Beim Schließen des Modals prevented jemand up:layer:dismiss, und dann steht "Abort Error: Close event was prevented" in der Konsole.
  - Wollen wir das schlucken?
  - Zumindest bei ui-elementen wie [up-dismiss] ?
- DestructorPass sammelt zwar Exceptions, aber wirft am Ende. Wer fängt das dann? Der Wunsch wäre, dass das drumrumliegende up.destroy() noch zu Ende läuft, dann aber up.CompilerError wirft.
- ConstructorPass sammelt zwar Exceptions, aber wirft am Ende. Wer fängt das dann? Der Wunsch wäre, dass das drumrumliegende up.render() oder up.hello() noch zu Ende läuft, dann aber mit up.CompilerError rejected.
- Update "Long Story" Slides with new API
- Doc page about "Fragments from local HTML"
  - link from [up-document], [up-fragment], [up-content], { document, fragment, content }.
- Warn when registering compiler in [up-] namespace
- Consider documenting errors
  - But what would be the @parent ?
  - up.CannotCompile
  - up.CannotMatch
  - up.Offline
  - up.AbortError
    - has { name: 'AbortError' }


Decisions
=========

- Should the old "clear" be "expire" or "evict"?
  => We really want to push our new defaults for both
  => I think it should be "expire". Most users set a lower expire time.
- remove up.util.flatMap() => No, we need it to flatMap array-like objects (e.g. arguments)
  - Do we want to move to saveState() / restoreState()?
    - I think we want to keep the [up-focus] and [up-scroll] options separate.
      - E.g. we want to focus the main element, but reset scroll.
      - This could also be fixed by revealSnap ?
    - These are eerily similar:
      - https://unpoly.com/scroll-option
      - https://unpoly.com/focus-option
      - The -if-lost suffix can only pertain to focus
    - What would be the name for such an attribute?
      - [up-spotlight]
      - [up-viewport] (classes with [up-viewport]
      - [up-highlight]
      - [up-locus]
      - [up-present]
      - [up-light]
      - [up-shine]
      - [up-state]   (seltsam: up-state=".element")
      - [up-point]
      - [up-pinpoint]
      - [up-attention]
      - [up-focus] also scrolls?
      - [up-show]
      - [up-view]
    => I think power users want to control this separately
    => Also we need to call it at different times
    => Also the auto options work differently, e.g. if there is an [autoscroll] element in the new fragment
    => We might offer a shortcut like [up-view] and [up-save-view] as a shortcut to set both at once
- Replace up.rails by accepting methods / conform from data attributes in options parser
  => This wouldn't work in scenarios where both Rails UJS and Unpoly were active
- No longer send X-Up-Location with every response
  => No we should keep sending it, as this excludes redirect-forwarded up-params
- Consider reverting: up:request:late: Consider the time a promoted request was loading in the background
  => For this we would need to track when a request was promoted to the foreground
- Do we trigger onFinished when preloading?
  => No, users can use the promise or onLoaded()
- Reconsider how many lifecycle callbacks we want to parse from links
  - Benchmark up.link.followOptions()
    - console.time('parse'); for (var i = 0; i < 10000; i++) { up.link.followOptions(link) }; console.timeEnd('parse')
    - VM481:1 parse: 1091.6689453125 ms
    => It takes 0.1 ms
    => This is not a performance issue
- Find a scenario where it's better to read the etag from [etag] instead of response.etag
  - This should not matter for revalidation after a swap
  - When reloading an arbitrary fragment, an earlier response may not be available
- Test if browsers honor cache keys for XHR requests
  - Yes, it honors Cache-Control: max-age=...
  - We can override it for fetch()
- With our long cache eviction background tabs could hog a lot of memory
  => No, since we also limit the number of cache entries to the cache never exceeds some MB
- up.link.cacheState(link) to people can build .offline classes themselves
  => Users can already use up.cache.get
  => We could clean up Request#state and publish this for more goodness
  - Return any known up.Respone for the given link
    - It already has useful properties { evictAge }, { expireAge }?
    - We may eventually offer up.Response#revalidate()
  - Return null while the request is in flight
    => Or do we want an up.CacheState that also returns here?
  - It will be hard to do implement this without actually calling up.link.follow() and up.render(), since e.g. the target choice is hard and part of the cache key
    - Make this an early return in up.Change.FromURL, like with options.preload
